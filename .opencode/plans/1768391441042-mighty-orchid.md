# DESIGN DOCUMENT: Fix Polymarket Pricing Information Download

## Problem Statement

The application is experiencing 404 errors when trying to fetch order book data:

```
Error parsing order book: 404 Client Error: Not Found for url: https://clob.polymarket.com/book?token_id=53135072462907880191400140706440867753044989936304433583131786753949599718775
Error using CLOB client: PolyApiException[status_code=404, error_message={'error': 'No orderbook exists for the requested token id'}], falling back to order book
Market prices: YES=$0.00 | NO=$0.00
Market price for YES: $0.00
```

## Root Cause Analysis

### Current Implementation Flow

**File:** `poly_market_trader/api/market_data_provider.py`

1. **Market Data Source** (Line 227, 43):
   - Uses Gamma API: `https://gamma-api.polymarket.com/markets`
   - Retrieves market details including `clobTokenIds` and `outcomePrices`

2. **Token ID Extraction** (Lines 381-396):
   ```python
   clob_token_ids_raw = market_details.get('clobTokenIds', '[]')
   if isinstance(clob_token_ids_raw, str):
       clob_token_ids = json_module.loads(clob_token_ids_raw)
   else:
       clob_token_ids = clob_token_ids_raw

   if len(clob_token_ids) >= 2:
       yes_token_id = clobTokenIds[0]  # YES token
       no_token_id = clobTokenIds[1]   # NO token
   ```

3. **Order Book Fetching** (Lines 239-254):
   ```python
   def get_order_book(self, token_id: str) -> Dict:
       if self.clob_client:
           try:
               return self.clob_client.get_order_book(token_id)
           except Exception as e:
               print(f"Error using CLOB client: {e}, falling back to HTTP")

       # Fallback to HTTP request
       response = requests.get(f"{self.clob_api_base}/book", params={'token_id': token_id})
       response.raise_for_status()
       return response.json()
   ```

4. **Price Fetching** (Lines 277-321):
   ```python
   def get_best_bid_ask(self, token_id: str) -> Dict[str, float]:
       if self.clob_client:
           try:
               bid = self.clob_client.get_price(token_id, side="BUY")
               ask = self.clob_client.get_price(token_id, side="SELL")
               # ... price calculations
           except Exception as e:
               print(f"Error using CLOB client: {e}, falling back to order book")

       # Fallback to order book parsing
       book = self.get_order_book(token_id)
       # ... parsing logic
   ```

### Issues Identified

1. **Token ID Validation Missing**: No validation of token IDs before using them
2. **404 Handling**: 404 errors are caught but don't distinguish between "invalid token" vs "no order book"
3. **Silent Failures**: Errors are logged but execution continues with zero prices
4. **Market Status Not Checked**: Doesn't check if market is active/closed/resolved
5. **Fallback Chain Too Long**: Multiple fallbacks make debugging difficult

## Reference: Official API Tutorial (Read-Only Access)

From [Polymarket Python Tutorial](https://www.polytrackhq.app/blog/polymarket-python-tutorial):

```python
from py_clob_client.client import ClobClient

# Level 0 - public data only (Read-Only Access)
client = ClobClient("https://clob.polymarket.com")

# Test connection
ok = client.get_ok()
server_time = client.get_server_time()

# Get all markets
markets = client.get_markets()
first = markets['data'][0]
print(f"Market: {first.get('question')}")
print(f"Condition ID: {first.get('condition_id')}")

# Get prices and order book
token_id = "YOUR_TOKEN_ID_HERE"

# Get midpoint price
mid = client.get_midpoint(token_id)

# Get best bid/ask
bid_price = client.get_price(token_id, side="BUY")
ask_price = client.get_price(token_id, side="SELL")

# Get full order book
book = client.get_order_book(token_id)
print(f"Bids: {book['bids'][:3]}")
print(f"Asks: {book['asks'][:3]}")

# Get last trade price
last_price = client.get_last_trade_price(token_id)
```

## Design: Proposed Fixes

### Phase 1: Diagnostics & Logging

**Objective:** Add detailed logging to understand the token IDs being used

1. **Add Token ID Logging** in `get_market_prices()`:
   - Log the exact token IDs extracted from `clobTokenIds`
   - Log the format/type of token IDs
   - Log the market status and condition ID

2. **Add API Response Logging**:
   - Log sample market data structure
   - Verify `clobTokenIds` format from Gamma API
   - Check if `outcomePrices` contain valid data

### Phase 2: Token ID Validation

**Objective:** Validate token IDs before using them

1. **Add Token ID Format Validation**:
   ```python
   def _validate_token_id(self, token_id: str) -> bool:
       """Validate token ID format before using it"""
       if not token_id or not isinstance(token_id, str):
           return False

       # Token IDs should be numeric strings
       if not token_id.isdigit():
           return False

       # Token IDs should be reasonable length (typically 20-40 digits)
       # Note: The error shows 78-digit IDs which might be too long
       if len(token_id) > 50:
           print(f"Warning: Token ID appears too long: {token_id[:10]}... (length={len(token_id)})")
           return False

       return True
   ```

2. **Add Token ID Existence Check**:
   ```python
   def _verify_token_exists(self, token_id: str) -> bool:
       """Verify if token ID exists in CLOB"""
       try:
           # Use get_price as a lightweight check
           price = self.clob_client.get_price(token_id, side="BUY")
           return price is not None
       except Exception as e:
           if "404" in str(e) or "No orderbook exists" in str(e):
               print(f"Token ID does not exist: {token_id}")
               return False
           return False
   ```

### Phase 3: Improved Error Handling

**Objective:** Better error handling and meaningful messages

1. **Specific 404 Handling**:
   ```python
   from requests.exceptions import HTTPError

   def get_order_book(self, token_id: str) -> Optional[Dict]:
       if not self._validate_token_id(token_id):
           print(f"Invalid token ID format: {token_id}")
           return None

       if self.clob_client:
           try:
               return self.clob_client.get_order_book(token_id)
           except Exception as e:
               error_str = str(e)
               if "404" in error_str or "No orderbook exists" in error_str:
                   print(f"No order book for token {token_id}: Market may not have liquidity yet")
                   return None
               print(f"Error using CLOB client: {e}, falling back to HTTP")

       try:
           response = requests.get(f"{self.clob_api_base}/book", params={'token_id': token_id})
           response.raise_for_status()
           return response.json()
       except HTTPError as e:
           if e.response.status_code == 404:
               print(f"Order book not found (404) for token: {token_id}")
               return None
           raise
   ```

2. **Market Status Checking**:
   ```python
   def get_market_prices(self, market_id: str) -> Dict[str, float]:
       market_details = self.get_market_by_id(market_id)

       # Check if market is active and open for trading
       active = market_details.get('active', False)
       closed = market_details.get('closed', True)
       end_date = market_details.get('endDate')

       if not active or closed:
           print(f"Market {market_id} is not active (active={active}, closed={closed})")
           return {'yes': 0.0, 'no': 0.0}

       # ... rest of implementation
   ```

### Phase 4: Alternative Price Sources

**Objective:** Implement fallback to alternative price sources

1. **Use outcomePrices First**:
   - Already implemented (lines 356-378)
   - Should be primary source before CLOB queries

2. **Add Last Trade Price Fallback**:
   ```python
   def get_market_prices(self, market_id: str) -> Dict[str, float]:
       # ... existing code ...

       # If outcomePrices are 0.0 and clobTokenIds fail, try last trade price
       if prices['yes'] == 0.0 and prices['no'] == 0.0:
           try:
               last_yes_price = self.clob_client.get_last_trade_price(yes_token_id)
               last_no_price = self.clob_client.get_last_trade_price(no_token_id)
               if last_yes_price:
                   prices['yes'] = float(last_yes_price)
               if last_no_price:
                   prices['no'] = float(last_no_price)
           except Exception:
               pass

       return prices
   ```

### Phase 5: Market Filtering

**Objective:** Filter out markets without order books

1. **Add Liquidity Check**:
   ```python
   def has_liquidity(self, token_id: str) -> bool:
       """Check if token has any liquidity (bids or asks)"""
       try:
           book = self.get_order_book(token_id)
           if not book:
               return False
           return len(book.get('bids', [])) > 0 or len(book.get('asks', [])) > 0
       except Exception:
           return False
   ```

2. **Filter Markets in Monitor**:
   - In `market_monitor.py`, filter out markets without liquidity
   - Skip markets that return 404 for token IDs

## Implementation Plan

### Step 1: Add Diagnostics (Temporary)

Add detailed logging to understand the token IDs:

```python
def get_market_prices(self, market_id: str) -> Dict[str, float]:
    market_details = self.get_market_by_id(market_id)

    # DIAGNOSTIC: Log market details
    print(f"\n=== DIAGNOSTIC: Market {market_id} ===")
    print(f"Active: {market_details.get('active')}")
    print(f"Closed: {market_details.get('closed')}")
    print(f"Condition ID: {market_details.get('condition_id')}")
    print(f"OutcomePrices: {market_details.get('outcomePrices')}")
    print(f"clobTokenIds: {market_details.get('clobTokenIds')}")
    print(f"===========================================\n")

    # ... rest of code
```

### Step 2: Validate Token IDs

Add the `_validate_token_id()` and `_verify_token_exists()` methods.

### Step 3: Update get_order_book()

Replace the current implementation with improved error handling.

### Step 4: Update get_best_bid_ask()

Add specific 404 handling and validation.

### Step 5: Update get_market_prices()

Add market status checking and alternative price sources.

### Step 6: Add Filter for Non-Liquid Markets

In services that use `get_market_prices()`, add filtering.

## Testing Plan

### Unit Tests

1. **Test Token ID Validation**:
   ```python
   def test_validate_token_id(self):
       # Valid numeric token ID
       self.assertTrue(self.provider._validate_token_id("12345678901234567890"))
       # Empty string
       self.assertFalse(self.provider._validate_token_id(""))
       # Non-string
       self.assertFalse(self.provider._validate_token_id(12345))
       # Too long
       self.assertFalse(self.provider._validate_token_id("1" * 78))
   ```

2. **Test 404 Error Handling**:
   ```python
   @patch('poly_market_trader.api.market_data_provider.ClobClient')
   def test_get_order_book_404(self, mock_clob_client):
       mock_client_instance = mock_clob_client.return_value
       mock_client_instance.get_order_book.side_effect = Exception("404 Not Found")

       result = self.provider.get_order_book("invalid_token")
       self.assertIsNone(result)
   ```

3. **Test Market Status Check**:
   ```python
   def test_get_market_prices_closed_market(self):
       # Mock a closed market
       mock_response = MagicMock()
       mock_response.json.return_value = [
           {"id": "1", "active": False, "closed": True}
       ]
       mock_response.raise_for_status.return_value = None

       with patch('poly_market_trader.api.market_data_provider.requests.get', return_value=mock_response):
           result = self.provider.get_market_prices("1")
           self.assertEqual(result['yes'], 0.0)
           self.assertEqual(result['no'], 0.0)
   ```

### Integration Tests

1. **Test with Real Markets**:
   - Fetch real markets from Polymarket
   - Verify token IDs are valid
   - Check order book retrieval

2. **Test Price Consistency**:
   - Compare `outcomePrices` vs `get_best_bid_ask()` vs `get_last_trade_price()`
   - Verify they return similar values when available

## Verification Checklist

- [ ] Token IDs are validated before use
- [ ] 404 errors are properly handled and logged
- [ ] Market status is checked before fetching prices
- [ ] Alternative price sources are used when CLOB fails
- [ ] Markets without liquidity are filtered out
- [ ] Unit tests pass for new validation methods
- [ ] Integration tests pass with real markets
- [ ] Error messages are clear and actionable
- [ ] Logs provide sufficient diagnostic information
- [ ] No regressions in existing functionality

## Files to Modify

1. **poly_market_trader/api/market_data_provider.py**:
   - Add `_validate_token_id()` method
   - Add `_verify_token_exists()` method
   - Update `get_order_book()` with better error handling
   - Update `get_best_bid_ask()` with validation
   - Update `get_market_prices()` with status checks and alternatives

2. **poly_market_trader/services/market_monitor.py**:
   - Add filtering for markets without liquidity
   - Handle zero-price markets gracefully

3. **tests/test_api.py**:
   - Add tests for token ID validation
   - Add tests for 404 error handling
   - Add tests for market status checking

## Expected Outcomes

After implementation:

1. **Clear Error Messages**:
   - Instead of: `"Error parsing order book: 404 Client Error..."`
   - We get: `"Market XYZ: No order book available (token ID: 123...). Market may not have liquidity yet."`

2. **Graceful Degradation**:
   - Uses `outcomePrices` when available
   - Falls back to `get_last_trade_price()` if order book empty
   - Returns 0.0 only when truly no price data available

3. **Market Filtering**:
   - Only actively trading markets are processed
   - Markets without order books are skipped with clear logs

4. **Diagnostic Information**:
   - Token IDs are logged for debugging
   - Market status is logged
   - Multiple price sources are tried and logged

## Risk Mitigation

1. **Temporary Diagnostic Mode**:
   - Add verbose logging that can be disabled
   - Remove diagnostic logs after issue is resolved

2. **Backward Compatibility**:
   - Keep existing method signatures
   - Return same data structures
   - Add validation as enhancement, not breaking change

3. **Performance Impact**:
   - Token ID validation is O(1)
   - Token existence check adds one API call per token
   - Cache validation results for performance

## Next Steps

1. **Run with Diagnostics**: First, run the application with detailed logging to see the actual token IDs and market data
2. **Identify Pattern**: Determine if invalid token IDs follow a specific pattern
3. **Implement Fixes**: Apply the proposed fixes incrementally
4. **Test Thoroughly**: Run unit and integration tests
5. **Monitor Production**: Check error logs after deployment

## Conclusion

The 404 errors are likely caused by one of the following:

1. **Invalid Token IDs**: `clobTokenIds` from Gamma API may not match CLOB token IDs
2. **Market Status**: Markets may be closed, inactive, or not yet open for trading
3. **No Liquidity**: Markets exist but have no order book entries yet
4. **API Changes**: Polymarket API may have changed the token ID format or location

The proposed solution adds validation, better error handling, and multiple fallback mechanisms to handle these scenarios gracefully while providing clear diagnostic information to identify the root cause.
